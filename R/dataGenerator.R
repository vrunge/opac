

######################################################
#############     dataGenerator2D    #################
######################################################

#' dataGenerator2D
#' @description Generating data for change-point detection in bivariate independent time series
#' @param chpts a vector of increasing change-point indices
#' @param means1 vector of successive segment means for time series 1
#' @param means2 vector of successive segment means for time series 2
#' @param sdNoise1 standard deviation of the Gaussian noise for time series 1
#' @param sdNoise2 standard deviation of the Gaussian noise for time series 2
#' @param type the model: gauss or poisson
#' @return a dataframe with two simulated time series with same length in component y1 and y2
#' @examples
#' myData <- dataGenerator2D(chpts = c(30,100,120), means1 = c(0,5,0), means2 = c(7,1,-4))
dataGenerator2D <- function(chpts = 100,
                            means1 = 0,
                            means2 = 0,
                            sdNoise1 = 1,
                            sdNoise2 = 1,
                            type = "gauss")
{
  ############
  ### STOP ###
  ############
  if(!is.numeric(chpts)){stop('chpts values are not all numeric')}
  if(is.unsorted(chpts)){stop('chpts should be an increasing vector of change-point positions (indices)')}
  if(length(unique(chpts)) < length(chpts)){stop('chpts is not a strictly increasing sequence')}
  if(!is.numeric(means1)){stop('means1 values are not all numeric')}
  if(!is.numeric(means2)){stop('means2 values are not all numeric')}
  if(length(chpts) != length(means1)){stop('chpts and means1 vectors are of different size')}
  if(length(chpts) != length(means2)){stop('chpts and means2 vectors are of different size')}
  if(sdNoise1 < 0){stop('sdNoise1 cannot be negative')}
  if(sdNoise2 < 0){stop('sdNoise2 cannot be negative')}
  if(type == "poisson"){if(min(c(means1, means2)) <= 0){stop('no negative mean allowed for Poisson model')}}

  n <- chpts[length(chpts)]
  repetition <- c(chpts[1], diff(chpts))
  mu1 <- rep(means1, repetition)
  mu2 <- rep(means2, repetition)
  if(type == "gauss")
  {
    y1 <- rnorm(n, mean = mu1, sd = sdNoise1)
    y2 <- rnorm(n, mean = mu2, sd = sdNoise2)
  }
  if(type == "poisson")
  {
    y1 <- rpois(n = n, lambda = mu1)
    y2 <- rpois(n = n, lambda = mu2)
  }
  return(data.frame(y1 = y1, y2 = y2))
}



###############################################################
#############     dataGeneratorRegression     #################
###############################################################

#' dataGeneratorRegression
#' @description Generating data for changes in bivariate independent time series
#' @param chpts a vector of increasing change-point indices
#' @param A vector of regression coefficients A in A*x+B simple regression model
#' @param B vector of regression coefficients B in A*x+B simple regression model
#' @param meansX vector of mean values for x values generated by a Gaussian model
#' @param sdX vector of standard deviation values for x values generated by a Gaussian model
#' @param sdNoise standard deviation of the Gaussian noise
#' @return a dataframe with time series x and y for change-points in regression of type y = A*x + B + noise
#' @examples
#' myData <- dataGeneratorRegression(chpts = c(40,90), A = c(2,-1),  B = c(-1,2), meansX = c(1,2))
dataGeneratorRegression <- function(chpts = 100,
                                    A = 2,
                                    B = -1,
                                    meansX = 0,
                                    sdX = 1,
                                    sdNoise = 1)
{
  ############
  ### STOP ###
  ############
  if(!is.numeric(chpts)){stop('data values are not all numeric')}
  if(is.unsorted(chpts)){stop('chpts should be an increasing vector of change-point positions (indices)')}
  if(length(unique(chpts)) < length(chpts)){stop('chpts is not a strictly increasing sequence')}
  if(length(chpts) != length(A)){stop('chpts and A vectors are of different size')}
  if(length(chpts) != length(B)){stop('chpts and B vectors are of different size')}
  if(min(sdX) < 0){stop('sdX cannot be negative')}

  if(length(meansX) == 1){meansX <- rep(meansX, length(chpts))}
  if(length(sdX) == 1){sdX <- rep(sdX, length(chpts))}
  if(length(chpts) != length(meansX)){stop('chpts and meansX vectors are of different size')}
  if(length(chpts) != length(sdX)){stop('chpts and sdX vectors are of different size')}

  n <- chpts[length(chpts)]
  repetition <- c(chpts[1], diff(chpts))
  A_rep <- rep(A, repetition)
  B_rep <- rep(B, repetition)
  meansX_rep <- rep(meansX, repetition)
  sdX_rep <- rep(sdX, repetition)

  x <- rnorm(n, mean = meansX_rep, sd = sdX_rep)
  y <- A_rep*x + B_rep + rnorm(n, mean = 0, sd = sdNoise)
  return(data.frame(x = x, y = y))
}


##########################################################
#############     dataGeneratorSlope     #################
##########################################################

#' dataGeneratorSlope
#' @description Generate data with a given continuous piece-wise linear model
#' @param chpts a vector of increasing change-point indices
#' @param kinks vector of successive kink values (kink heights)
#' @param varNoise variance of the Gaussian noise
#' @param type the model: gauss or poisson
#' @return a vector of (univariate) simulated data following the (chpts, kinks) 2D data-points.
#' @examples
#' myData <- dataGeneratorSlope(chpts = c(1,30,100,150), kinks = c(-2,pi,0.001,2.1), varNoise = 0.1)
dataGeneratorSlope <- function(chpts = c(1, 100), kinks = c(1, 5), varNoise = 0.1, type = "gauss")
{
  ############
  ### STOP ###
  ############
  if(!is.numeric(chpts)){stop('data values are not all numeric')}
  if(is.unsorted(chpts)){stop('chpts should be an increasing vector')}
  if(length(unique(chpts)) < length(chpts)){stop('chpts is not a strictly increasing sequence')}

  if(!is.numeric(kinks)){stop('kinks are not all numeric')}
  if(length(chpts) != length(kinks)){stop('chpts and kinks vectors are of different size')}
  if(!is.double(varNoise)){stop('varNoise is not a double.')}
  if(varNoise < 0){stop('varNoise must be nonnegative')}
  if(type == "poisson"){if(min(kinks) <= 0){stop('no negative mean allowed for Poisson model')}}

  steps <- diff(kinks)/diff(chpts)
  response <- c(kinks[1], cumsum(rep(steps, diff(chpts))) + kinks[1])

  if(type == "gauss")
  {
    response <- response + rnorm(length(response), 0, sqrt(varNoise))
  }
  if(type == "poisson")
  {
    response <- rpois(length(response), response)
  }
  return(response)
}



